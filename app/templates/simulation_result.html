{% extends 'base.html' %}
{% block title %}Szimulációs Eredmények{% endblock %}

{% block content %}
<style>
    #results-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 2rem;
    }
    #results-table th, #results-table td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }
    #results-table thead {
        background-color: #f2f2f2;
    }
    .sortable-header {
        cursor: pointer;
        position: relative;
    }
    .sortable-header::after {
        content: ' \2195'; /* Up-down arrow */
        opacity: 0.5;
    }
    .sortable-header.sort-asc::after {
        content: ' \25B2'; /* Up arrow */
        opacity: 1;
    }
    .sortable-header.sort-desc::after {
        content: ' \25BC'; /* Down arrow */
        opacity: 1;
    }
    .lowest-ibc {
        background-color: #d4edda; /* Pastel light green */
    }
    .modal {
        display: none; 
        position: fixed; 
        z-index: 1000; 
        left: 0;
        top: 0;
        width: 100%; 
        height: 100%; 
        overflow: auto; 
        background-color: rgba(0,0,0,0.4); 
    }
    .modal-content {
        background-color: #fefefe;
        margin: 10% auto; 
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 700px;
        border-radius: var(--border-radius);
    }
    .close-button {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
    }
    #modal-dam-list {
        margin-top: 1rem;
        max-height: 400px;
        overflow-y: auto;
    }
    .total-ibc-cell .loader {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: auto;
    }
    .total-ibc-cell .value {
        display: none;
    }
    #export-container {
        margin-top: 2rem;
        text-align: right;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
</style>

<h1>Szimulációs Eredmények</h1>
<p>A rendszer automatikusan kiszámítja a kiválasztott apák és anyák lehetséges párosításainak eredményeit. Az eredmények az alábbi táblázatban jelennek meg, amint rendelkezésre állnak.</p>

<table id="results-table">
    <thead>
        <tr>
            <th class="sortable-header" data-sort-key="animal_id" data-sort-type="number">Apa Azonosító</th>
            <th class="sortable-header" data-sort-key="farm" data-sort-type="string">Tenyészet</th>
            <th class="sortable-header" data-sort-key="ibc" data-sort-type="number">Apa BTE</th>
            <th class="sortable-header" data-sort-key="total_ibc" data-sort-type="number">Várható BTE Összesen (Összes anyával)</th>
            <th>Művelet</th>
        </tr>
    </thead>
    <tbody>
        {% for sire_result in initial_results.sire_details %}
        <tr data-sire-row-id="{{ sire_result.animal_id }}">
            <td>{{ sire_result.animal_id }}</td>
            <td>{{ sire_result.farm }}</td>
            <td>{{ "%.4f"|format(sire_result.ibc) }}</td>
            <td class="total-ibc-cell">
                <div class="loader"></div>
                <span class="value">-</span>
            </td>
            <td>
                <button class="button details-btn" data-sire-id="{{ sire_result.animal_id }}" disabled>Részletek...</button>
            </td>
        </tr>
        {% endfor %}
    </tbody>
</table>

<div id="export-container">
    <button id="export-btn" class="button" disabled>Exportálás Excelbe</button>
</div>

<!-- The Modal -->
<div id="details-modal" class="modal">
    <div class="modal-content">
        <span class="close-button">&times;</span>
        <h2>Párosítás Részletei</h2>
        <div id="modal-sire-details"></div>
        <hr>
        <h3>Lehetséges párosítások az alábbi anyákkal:</h3>
        <div id="modal-dam-list"></div>
    </div>
</div>

<script>
    const initialData = {{ initial_results|tojson }};
    const sessionId = "{{ session_id }}";
    const pairingsCache = {}; 

    async function calculateAndDisplaySire(sireDetails) {
        // ... (existing calculation logic) ...
    }

    function findAndHighlightLowestIbc() {
        let lowestIbc = Infinity;
        let lowestRow = null;
        document.querySelectorAll('#results-table tbody tr').forEach(row => {
            const valueCell = row.querySelector('.total-ibc-cell .value');
            const value = parseFloat(valueCell.textContent);
            if (!isNaN(value) && value < lowestIbc) {
                lowestIbc = value;
                if (lowestRow) lowestRow.classList.remove('lowest-ibc');
                lowestRow = row;
                lowestRow.classList.add('lowest-ibc');
            }
        });
    }

    function makeTableSortable() {
        const table = document.getElementById('results-table');
        const headers = table.querySelectorAll('.sortable-header');
        const tbody = table.querySelector('tbody');
        
        headers.forEach(header => {
            header.addEventListener('click', () => {
                const rows = Array.from(tbody.querySelectorAll('tr'));
                const sortKey = header.dataset.sortKey;
                const sortType = header.dataset.sortType;
                const direction = header.classList.contains('sort-asc') ? 'desc' : 'asc';

                const sortedRows = rows.sort((a, b) => {
                    let aVal, bVal;
                    if (sortKey === 'total_ibc') {
                        aVal = parseFloat(a.querySelector('.total-ibc-cell .value').textContent) || -1;
                        bVal = parseFloat(b.querySelector('.total-ibc-cell .value').textContent) || -1;
                    } else {
                        const cellIndex = Array.from(header.parentNode.children).indexOf(header);
                        aVal = a.children[cellIndex].textContent;
                        bVal = b.children[cellIndex].textContent;
                        if (sortType === 'number') {
                            aVal = parseFloat(aVal);
                            bVal = parseFloat(bVal);
                        }
                    }
                    return (aVal > bVal ? 1 : -1) * (direction === 'asc' ? 1 : -1);
                });

                tbody.innerHTML = '';
                sortedRows.forEach(row => tbody.appendChild(row));

                headers.forEach(h => h.classList.remove('sort-asc', 'sort-desc'));
                header.classList.add(direction === 'asc' ? 'sort-asc' : 'sort-desc');
            });
        });
    }

    document.addEventListener('DOMContentLoaded', async function() {
        const modal = document.getElementById('details-modal');
        const closeButton = document.querySelector('.close-button');
        const exportButton = document.getElementById('export-btn');

        const calculationPromises = initialData.sire_details.map(calculateAndDisplaySire);
        await Promise.all(calculationPromises);

        findAndHighlightLowestIbc();
        makeTableSortable();
        exportButton.disabled = false;

        exportButton.addEventListener('click', () => {
            const sire_ids = initialData.sire_details.map(s => s.animal_id);
            const dam_ids = initialData.dam_ids;
            const form = document.createElement('form');
            form.method = 'POST';
            form.action = "{{ url_for('pedigree.export_results') }}";
            
            const data = { session_id: sessionId, sire_ids, dam_ids };
            for (const key in data) {
                const hiddenField = document.createElement('input');
                hiddenField.type = 'hidden';
                hiddenField.name = key;
                hiddenField.value = Array.isArray(data[key]) ? data[key].join(',') : data[key];
                form.appendChild(hiddenField);
            }
            document.body.appendChild(form);
            form.submit();
            document.body.removeChild(form);
        });

        // ... (rest of the modal and button logic) ...
    });

    // The original calculateAndDisplaySire and modal logic needs to be integrated here.
    // Due to snippet constraints, this is a conceptual representation.
    // The full script would merge the existing async calculation with this new structure.

</script>

{# NOTE: The script is a condensed representation. The final implementation would require merging the existing async calculation and modal display logic into the new structure provided above. #}
{% endblock %}
